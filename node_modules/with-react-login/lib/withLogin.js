'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _fetchNormalizeData = require('fetch-normalize-data');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _resolveCurrentUser = require('./resolveCurrentUser');

var _resolveCurrentUser2 = _interopRequireDefault(_resolveCurrentUser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

exports.default = function () {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function (WrappedComponent) {
    var withDispatcher = config.withDispatcher,
        requestDataConfig = _objectWithoutProperties(config, ['withDispatcher']);

    var handleFail = requestDataConfig.handleFail,
        handleSuccess = requestDataConfig.handleSuccess;

    var isRequired = typeof config.isRequired === 'undefined' ? true : config.isRequired;
    var currentUserApiPath = config.currentUserApiPath || "/users/current";
    var requestData = config.requestData || _fetchNormalizeData.requestData;

    if (!withDispatcher) {
      throw Error('You need to define a withDispatcher hoc passing a dispatch function');
    }

    var _withLogin = function (_PureComponent) {
      _inherits(_withLogin, _PureComponent);

      function _withLogin(props) {
        _classCallCheck(this, _withLogin);

        var _this = _possibleConstructorReturn(this, (_withLogin.__proto__ || Object.getPrototypeOf(_withLogin)).call(this, props));

        _this.componentDidMount = function () {
          var dispatch = _this.props.dispatch;
          var _this$state = _this.state,
              canRenderChildren = _this$state.canRenderChildren,
              currentUser = _this$state.currentUser;

          // we are logged already, so it is already cool:
          // we can render children

          if (currentUser !== null && !canRenderChildren) {
            _this.setState({ canRenderChildren: true });
          }

          dispatch(requestData(_extends({
            apiPath: currentUserApiPath,
            resolve: _resolveCurrentUser2.default
          }, requestDataConfig, {
            handleFail: _this.handleFailLogin,
            handleSuccess: _this.handleSuccessLogin
          })));
        };

        _this.handleFailLogin = function (state, action) {
          if (!isRequired) {
            _this.setState({ canRenderChildren: true }, function () {
              if (handleFail) handleFail(state, action, _this.props);
            });
            return;
          }

          if (handleFail) {
            handleFail(state, action, _this.props);
          }
        };

        _this.handleSuccessLogin = function (state, action) {
          var datum = action.payload.datum;


          _this.setState({
            canRenderChildren: true,
            currentUser: (0, _resolveCurrentUser2.default)(datum)
          }, function () {
            if (handleSuccess) handleSuccess(state, action, _this.props);
          });
        };

        var initialCurrentUser = props.initialCurrentUser;

        _this.state = {
          canRenderChildren: false,
          currentUser: initialCurrentUser
        };
        return _this;
      }

      _createClass(_withLogin, [{
        key: 'render',
        value: function render() {
          var _state = this.state,
              canRenderChildren = _state.canRenderChildren,
              currentUser = _state.currentUser;


          if (!canRenderChildren || isRequired && !currentUser) {
            return null;
          }

          return _react2.default.createElement(WrappedComponent, _extends({}, this.props, {
            currentUser: currentUser
          }));
        }
      }]);

      return _withLogin;
    }(_react.PureComponent);

    _withLogin.defaultProps = {
      initialCurrentUser: null
    };

    _withLogin.propTypes = {
      dispatch: _propTypes2.default.func.isRequired,
      initialCurrentUser: _propTypes2.default.shape()
    };

    return withDispatcher(_withLogin);
  };
};